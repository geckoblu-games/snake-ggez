{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hello","title":"Introduction"},{"location":"00_projectsetup/","text":"Create a project To get started, make a new folder and initialize a Rust project with cargo init . If you don't have rust installed, install it with rustup . If you're on Linux rustup is probably already in your distro's repositories. After running cargo init , you should have a folder structure like this: . \u251c\u2500\u2500 Cargo.lock \u251c\u2500\u2500 Cargo.toml \u2514\u2500\u2500 src \u2514\u2500\u2500 main.rs Cargo.toml contains the manifest info for your Rust crate (crate is Rustacean for package). Mine looks like this: [package] name = \"snake-ggez\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] The src/ directory is where all of your Rust code goes. main.rs comes with Hello World already written: fn main() { println!(\"Hello, world!\"); } Run cargo build to build your project, and cargo run to run it. If you just want to check for project for syntax and type errors, run cargo check . It's a lot faster than cargo build . ggez basics Adding ggez as a dependency is pretty simple. Just go to the dependencies section of your Cargo.toml and add ggez = \"0.8\" [package] name = \"snake-ggez\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] ggez = \"0.8\" Run cargo build now to download and build ggez and all of its dependencies. It might take a few minutes. The behavior of the program hasn't actually changed at all yet. cargo run will still just output \"Hello,","title":"Project setup"},{"location":"00_projectsetup/#create-a-project","text":"To get started, make a new folder and initialize a Rust project with cargo init . If you don't have rust installed, install it with rustup . If you're on Linux rustup is probably already in your distro's repositories. After running cargo init , you should have a folder structure like this: . \u251c\u2500\u2500 Cargo.lock \u251c\u2500\u2500 Cargo.toml \u2514\u2500\u2500 src \u2514\u2500\u2500 main.rs Cargo.toml contains the manifest info for your Rust crate (crate is Rustacean for package). Mine looks like this: [package] name = \"snake-ggez\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] The src/ directory is where all of your Rust code goes. main.rs comes with Hello World already written: fn main() { println!(\"Hello, world!\"); } Run cargo build to build your project, and cargo run to run it. If you just want to check for project for syntax and type errors, run cargo check . It's a lot faster than cargo build .","title":"Create a project"},{"location":"00_projectsetup/#ggez-basics","text":"Adding ggez as a dependency is pretty simple. Just go to the dependencies section of your Cargo.toml and add ggez = \"0.8\" [package] name = \"snake-ggez\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] ggez = \"0.8\" Run cargo build now to download and build ggez and all of its dependencies. It might take a few minutes. The behavior of the program hasn't actually changed at all yet. cargo run will still just output \"Hello,","title":"ggez basics"},{"location":"01_justawindow/","text":"Time to start using ggez. We will try just to open a Window. From ggez's side, we'll need a Context , which is an object that provides access to the hardware: video for displaying the game, audio for playing sounds, keyboard for input and so on. A Context can be obtained from a ContextBuilder . To make a ContextBuilder you'll need a game ID. This will be used for the name of a directory in ~/.local/share on the player's computer, where game resources can be stored (see the filesystem module). You also need to provide a name for the game's author, but that's not used for GNU/Linux. To create them just call: let (mut ctx, event_loop) = ContextBuilder::new(\"hello-ggez\", \"author\").build() We could now start the event loop, but we need first an EventHandler . Were the logic of our game will reside. Just define a struct: struct MyGame {} and then implement the minimal EventHandler trait impl EventHandler for MyGame { fn update(&mut self, _ctx: &mut Context) -> GameResult { todo!() // todo!() is a macro which just exits the program with an error. } fn draw(&mut self, ctx: &mut Context) -> GameResult { todo!() } } Putting all together: use ggez::event::EventHandler; use ggez::Context; use ggez::ContextBuilder; use ggez::GameResult; fn main() { let (ctx, event_loop) = ContextBuilder::new(\"hello-ggez\", \"author\") .build() .expect(\"Could not create ggez context!\"); let my_game = MyGame {}; event::run(ctx, event_loop, my_game) } struct MyGame {} impl EventHandler for MyGame { fn update(&mut self, _ctx: &mut Context) -> GameResult { todo!() // todo!() is a macro which just exits the program with an error. } fn draw(&mut self, ctx: &mut Context) -> GameResult { todo!() } } Now try to run it and ... nothing! The application just panic. thread 'main' panicked at 'not yet implemented', src/main.rs:21:9 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace Nothing special, the event_loop is just calling the update() method with has just a todo!() , so try a nicer empty implementation. impl EventHandler for MyGame { fn update(&mut self, _ctx: &mut Context) -> GameResult { Ok(()) } fn draw(&mut self, ctx: &mut Context) -> GameResult { Ok(()) } } Try to run again and this time a Window appears ( Esc or Alt-F4 to close). We are drawing nothing so the Window background could display some garbage, better to color it: impl EventHandler for MyGame { ... fn draw(&mut self, ctx: &mut Context) -> GameResult { // Just a color for the background let color = Color::from([0.1, 0.2, 0.3, 1.0]); // Create a new Canvas that renders directly to the window surface. let canvas = Canvas::from_frame(ctx, color); // Finish drawing with this canvas and submit all the draw calls. canvas.finish(ctx) } } Canvas are the main places for drawing in ggez. Drawing are not made directly to the screen but instead on an internal buffer, so remeber to call finish() at the end to flush drawings or you will not see them. run another time and we finally have our fancy Window. As we are working with windows let set some attributes like title and size: let (ctx, event_loop) = ContextBuilder::new(\"snake-ggez\", \"author\") .window_setup(WindowSetup::default().title(\"Snake ggez\")) .window_mode(WindowMode::default().dimensions(800.0, 640.0)) .build() Read the documentation of WindowSetup and WindowMode for a complete list of attributes. You could find the complete source of this lesson here","title":"Open a Window"}]}