{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This tutorial will walk you through creating a simple Snake game in the Rust programming language step-by-step using ggez . I'm currently learning both Rust and ggez so what follows is my best understanding of both but don't necessary the best way for do it. Suggestions and corrections are always welcome. At the time of writing Rust is at 2021 edition and ggez is at version 0.8.1 . I will try to keep this tutorial up-to-date. The complete source code of this tutorial is available here . See also the examples for the code of the various lessons.","title":"Introduction"},{"location":"00_projectsetup/","text":"Create a project To get started, make a new folder and initialize a Rust project with cargo init . If you don't have rust installed, install it with rustup . If you're on Linux rustup is probably already in your distro's repositories. After running cargo init , you should have a folder structure like this: . \u251c\u2500\u2500 Cargo.lock \u251c\u2500\u2500 Cargo.toml \u2514\u2500\u2500 src \u2514\u2500\u2500 main.rs Cargo.toml contains the manifest info for your Rust crate (crate is Rustacean for package). Mine looks like this: [package] name = \"snake-ggez\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] The src/ directory is where all of your Rust code goes. main.rs comes with Hello World already written: fn main() { println!(\"Hello, world!\"); } Run cargo build to build your project, and cargo run to run it. If you just want to check for project for syntax and type errors, run cargo check . It's a lot faster than cargo build . ggez basics Adding ggez as a dependency is pretty simple. Just go to the dependencies section of your Cargo.toml and add ggez = \"0.8\" [package] name = \"snake-ggez\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] ggez = \"0.8.1\" Run cargo build now to download and build ggez and all of its dependencies. It might take a few minutes. The behavior of the program hasn't actually changed at all yet. cargo run will still just output \"Hello,","title":"Project setup"},{"location":"00_projectsetup/#create-a-project","text":"To get started, make a new folder and initialize a Rust project with cargo init . If you don't have rust installed, install it with rustup . If you're on Linux rustup is probably already in your distro's repositories. After running cargo init , you should have a folder structure like this: . \u251c\u2500\u2500 Cargo.lock \u251c\u2500\u2500 Cargo.toml \u2514\u2500\u2500 src \u2514\u2500\u2500 main.rs Cargo.toml contains the manifest info for your Rust crate (crate is Rustacean for package). Mine looks like this: [package] name = \"snake-ggez\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] The src/ directory is where all of your Rust code goes. main.rs comes with Hello World already written: fn main() { println!(\"Hello, world!\"); } Run cargo build to build your project, and cargo run to run it. If you just want to check for project for syntax and type errors, run cargo check . It's a lot faster than cargo build .","title":"Create a project"},{"location":"00_projectsetup/#ggez-basics","text":"Adding ggez as a dependency is pretty simple. Just go to the dependencies section of your Cargo.toml and add ggez = \"0.8\" [package] name = \"snake-ggez\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] ggez = \"0.8.1\" Run cargo build now to download and build ggez and all of its dependencies. It might take a few minutes. The behavior of the program hasn't actually changed at all yet. cargo run will still just output \"Hello,","title":"ggez basics"},{"location":"01_justawindow/","text":"Time to start using ggez. We will try just to open a Window. From ggez's side, we'll need a Context , which is an object that provides access to the hardware: video for displaying the game, audio for playing sounds, keyboard for input and so on. A Context can be obtained from a ContextBuilder . To make a ContextBuilder you'll need a game ID. This will be used for the name of a directory in ~/.local/share on the player's computer, where game resources can be stored (see the filesystem module). You also need to provide a name for the game's author, but that's not used for GNU/Linux. To create them just call: let (mut ctx, event_loop) = ContextBuilder::new(\"hello-ggez\", \"author\").build() We could now start the event loop, but we need first an EventHandler . Were the logic of our game will reside. Just define a struct: struct MyGame {} and then implement the minimal EventHandler trait impl EventHandler for MyGame { fn update(&mut self, _ctx: &mut Context) -> GameResult { todo!() // todo!() is a macro which just exits the program with an error. } fn draw(&mut self, ctx: &mut Context) -> GameResult { todo!() } } Putting all together: use ggez::event::EventHandler; use ggez::Context; use ggez::ContextBuilder; use ggez::GameResult; fn main() { let (ctx, event_loop) = ContextBuilder::new(\"hello-ggez\", \"author\") .build() .expect(\"Could not create ggez context!\"); let my_game = MyGame {}; event::run(ctx, event_loop, my_game) } struct MyGame {} impl EventHandler for MyGame { fn update(&mut self, _ctx: &mut Context) -> GameResult { todo!() // todo!() is a macro which just exits the program with an error. } fn draw(&mut self, ctx: &mut Context) -> GameResult { todo!() } } Now try to run it and ... nothing! The application just panic. thread 'main' panicked at 'not yet implemented', src/main.rs:21:9 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace Nothing special, the event_loop is just calling the update() method with has just a todo!() , so try a nicer empty implementation. impl EventHandler for MyGame { fn update(&mut self, _ctx: &mut Context) -> GameResult { Ok(()) } fn draw(&mut self, ctx: &mut Context) -> GameResult { Ok(()) } } Try to run again and this time a Window appears ( Esc to close). We are drawing nothing so the Window background could display some garbage, better to color it: impl EventHandler for MyGame { ... fn draw(&mut self, ctx: &mut Context) -> GameResult { // Just a color for the background let color = Color::from([0.1, 0.2, 0.3, 1.0]); // Create a new Canvas that renders directly to the window surface. let canvas = Canvas::from_frame(ctx, color); // Finish drawing with this canvas and submit all the draw calls. canvas.finish(ctx) } } Canvas are the main places for drawing in ggez. Drawing are not made directly to the screen but instead on an internal buffer, so remeber to call finish() at the end to flush drawings or you will not see them. run another time and we finally have our fancy Window. As we are working with windows let set some attributes like title and size: let (ctx, event_loop) = ContextBuilder::new(\"snake-ggez\", \"author\") .window_setup(WindowSetup::default().title(\"Snake ggez\")) .window_mode(WindowMode::default().dimensions(800.0, 640.0)) .build() Read the documentation of WindowSetup and WindowMode for a complete list of attributes. You could find the complete source of this lesson here","title":"Open a Window"},{"location":"02_drawanimage/","text":"To write a game we need graphics, right? So let's start drawing something. Draw a shape The Canvas has a method draw(...) which we can use: pub fn draw(&mut self, drawable: &impl Drawable, param: impl Into<DrawParam>) So first we need a Drawable . We start with a simple sqare for the head of our snake: let head_color = Color::new(0.0, 1.0, 0.0, 1.0); let rect = Rect::new(10.0, 20.0, 32.0, 32.0); let head = Mesh::new_rectangle(ctx, DrawMode::fill(), rect, head_color)?; canvas.draw(&head, DrawParam::default()); So we first define the Color of our head, then the Rect : Rect::new(pos_x, pos_y, width, height) and finally we could create a Mesh which implemens the Drawable method. Note the DrawMode for the Mesh which is fill in our case (a filled shape) and the DrawParam for the draw(...) method which we will ignore for the moment setting it at its default values. Putting all together use ggez::conf::WindowMode; use ggez::conf::WindowSetup; use ggez::event; use ggez::event::EventHandler; use ggez::graphics::Canvas; use ggez::graphics::Color; use ggez::graphics::DrawMode; use ggez::graphics::DrawParam; use ggez::graphics::Mesh; use ggez::graphics::Rect; use ggez::Context; use ggez::ContextBuilder; use ggez::GameResult; fn main() { let (ctx, event_loop) = ContextBuilder::new(\"snake-ggez\", \"author\") .window_setup(WindowSetup::default().title(\"Snake ggez\")) .window_mode(WindowMode::default().dimensions(800.0, 640.0)) .build() .expect(\"Could not create ggez context!\"); let my_game = MyGame {}; event::run(ctx, event_loop, my_game) } struct MyGame {} impl EventHandler for MyGame { fn update(&mut self, _ctx: &mut Context) -> GameResult { Ok(()) } fn draw(&mut self, ctx: &mut Context) -> GameResult { // Just a color for the background let background_color = Color::new(0.1, 0.2, 0.3, 1.0); // Create a new Canvas that renders directly to the window surface. let mut canvas = Canvas::from_frame(ctx, background_color); // Create the snake head let head_color = Color::new(0.0, 1.0, 0.0, 1.0); let rect = Rect::new(10.0, 20.0, 32.0, 32.0); let head = Mesh::new_rectangle(ctx, DrawMode::fill(), rect, head_color)?; // Draw the snake head canvas.draw(&head, DrawParam::default()); // Finish drawing with this canvas and submit all the draw calls. canvas.finish(ctx) } } Is possible to write a game combining various shapes but I prefer to use images, so ... Draw an image Let's start with a minor problem. In order to display an image in the game, we need to have it stored somewhere. At runtime, ggez will look for resources in the resources/ directory next to the executable (not in $PWD ), or in resources.zip in the same place or in ~/.local/share/<gameid>/ . See also the documentation of the filesystem module and the FAQ entry about resource paths . You'll probably want to have a resources directory in the project's root and create a symbolic link to it in target/debug . . \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 resources \u2502 \u2514\u2500\u2500 my_image.png \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 main.rs \u2514\u2500\u2500 target \u2514\u2500\u2500 debug \u2514\u2500\u2500 resources -> ../../resources/ on github you can find the images for this lesson. To load an image resource we just need a Context and a path let image1 = graphics::Image::new(ctx, \"/my_image.png\")?; The image might be needed for the entire duration of the game, so a good owner for it might be a field of the game state struct. Also, we want to load the image as soon as the game starts, so we could do it in the new() function of the game state. Since Image::new() takes a &mut Context , so will the new() function. struct MyGame { head_image: Image, } impl MyGame { pub fn new(ctx: &mut Context) -> GameResult<MyGame> { let head_image = Image::from_path(ctx, \"/snakehead.png\")?; let g = MyGame { head_image }; Ok(g) } } and then just let my_dest = Vec2::new(500.0, 200.0); canvas.draw(&self.image1, DrawParam::default().dest(my_dest)); so we display the head PNG instead of the simple green sqauare we have drawn before. Note that an Image hasn't a destination position so we need to set the destination using the DrawParam . You could find the complete source of this lesson here","title":"Draw an Image"},{"location":"02_drawanimage/#draw-a-shape","text":"The Canvas has a method draw(...) which we can use: pub fn draw(&mut self, drawable: &impl Drawable, param: impl Into<DrawParam>) So first we need a Drawable . We start with a simple sqare for the head of our snake: let head_color = Color::new(0.0, 1.0, 0.0, 1.0); let rect = Rect::new(10.0, 20.0, 32.0, 32.0); let head = Mesh::new_rectangle(ctx, DrawMode::fill(), rect, head_color)?; canvas.draw(&head, DrawParam::default()); So we first define the Color of our head, then the Rect : Rect::new(pos_x, pos_y, width, height) and finally we could create a Mesh which implemens the Drawable method. Note the DrawMode for the Mesh which is fill in our case (a filled shape) and the DrawParam for the draw(...) method which we will ignore for the moment setting it at its default values. Putting all together use ggez::conf::WindowMode; use ggez::conf::WindowSetup; use ggez::event; use ggez::event::EventHandler; use ggez::graphics::Canvas; use ggez::graphics::Color; use ggez::graphics::DrawMode; use ggez::graphics::DrawParam; use ggez::graphics::Mesh; use ggez::graphics::Rect; use ggez::Context; use ggez::ContextBuilder; use ggez::GameResult; fn main() { let (ctx, event_loop) = ContextBuilder::new(\"snake-ggez\", \"author\") .window_setup(WindowSetup::default().title(\"Snake ggez\")) .window_mode(WindowMode::default().dimensions(800.0, 640.0)) .build() .expect(\"Could not create ggez context!\"); let my_game = MyGame {}; event::run(ctx, event_loop, my_game) } struct MyGame {} impl EventHandler for MyGame { fn update(&mut self, _ctx: &mut Context) -> GameResult { Ok(()) } fn draw(&mut self, ctx: &mut Context) -> GameResult { // Just a color for the background let background_color = Color::new(0.1, 0.2, 0.3, 1.0); // Create a new Canvas that renders directly to the window surface. let mut canvas = Canvas::from_frame(ctx, background_color); // Create the snake head let head_color = Color::new(0.0, 1.0, 0.0, 1.0); let rect = Rect::new(10.0, 20.0, 32.0, 32.0); let head = Mesh::new_rectangle(ctx, DrawMode::fill(), rect, head_color)?; // Draw the snake head canvas.draw(&head, DrawParam::default()); // Finish drawing with this canvas and submit all the draw calls. canvas.finish(ctx) } } Is possible to write a game combining various shapes but I prefer to use images, so ...","title":"Draw a shape"},{"location":"02_drawanimage/#draw-an-image","text":"Let's start with a minor problem. In order to display an image in the game, we need to have it stored somewhere. At runtime, ggez will look for resources in the resources/ directory next to the executable (not in $PWD ), or in resources.zip in the same place or in ~/.local/share/<gameid>/ . See also the documentation of the filesystem module and the FAQ entry about resource paths . You'll probably want to have a resources directory in the project's root and create a symbolic link to it in target/debug . . \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 resources \u2502 \u2514\u2500\u2500 my_image.png \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 main.rs \u2514\u2500\u2500 target \u2514\u2500\u2500 debug \u2514\u2500\u2500 resources -> ../../resources/ on github you can find the images for this lesson. To load an image resource we just need a Context and a path let image1 = graphics::Image::new(ctx, \"/my_image.png\")?; The image might be needed for the entire duration of the game, so a good owner for it might be a field of the game state struct. Also, we want to load the image as soon as the game starts, so we could do it in the new() function of the game state. Since Image::new() takes a &mut Context , so will the new() function. struct MyGame { head_image: Image, } impl MyGame { pub fn new(ctx: &mut Context) -> GameResult<MyGame> { let head_image = Image::from_path(ctx, \"/snakehead.png\")?; let g = MyGame { head_image }; Ok(g) } } and then just let my_dest = Vec2::new(500.0, 200.0); canvas.draw(&self.image1, DrawParam::default().dest(my_dest)); so we display the head PNG instead of the simple green sqauare we have drawn before. Note that an Image hasn't a destination position so we need to set the destination using the DrawParam . You could find the complete source of this lesson here","title":"Draw an image"}]}