{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This tutorial will walk you through creating a simple Snake game in the Rust programming language step-by-step using ggez . I'm currently learning both Rust and ggez so what follows is my best understanding of both but don't necessary the best way for do it. Suggestions and corrections are always welcome. At the time of writing Rust is at 2021 edition and ggez is at version 0.8.1 . I will try to keep this tutorial up-to-date. The complete source code of this tutorial is available here . See also the examples for the code of the various lessons. References A tanks to: Hello ggez Pong tutorial with ggez Ggez Snake example","title":"Introduction"},{"location":"#references","text":"A tanks to: Hello ggez Pong tutorial with ggez Ggez Snake example","title":"References"},{"location":"00_projectsetup/","text":"Create a project To get started, make a new folder and initialize a Rust project with cargo init . If you don't have rust installed, install it with rustup . If you're on Linux rustup is probably already in your distro's repositories. After running cargo init , you should have a folder structure like this: . \u251c\u2500\u2500 Cargo.lock \u251c\u2500\u2500 Cargo.toml \u2514\u2500\u2500 src \u2514\u2500\u2500 main.rs Cargo.toml contains the manifest info for your Rust crate (crate is Rustacean for package). Mine looks like this: [package] name = \"snake-ggez\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] The src/ directory is where all of your Rust code goes. main.rs comes with Hello World already written: fn main() { println!(\"Hello, world!\"); } Run cargo build to build your project, and cargo run to run it. If you just want to check for project for syntax and type errors, run cargo check . It's a lot faster than cargo build . ggez basics Adding ggez as a dependency is pretty simple. Just go to the dependencies section of your Cargo.toml and add ggez = \"0.8\" [package] name = \"snake-ggez\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] ggez = \"0.8.1\" Run cargo build now to download and build ggez and all of its dependencies. It might take a few minutes. The behavior of the program hasn't actually changed at all yet. cargo run will still just output \"Hello,","title":"Project setup"},{"location":"00_projectsetup/#create-a-project","text":"To get started, make a new folder and initialize a Rust project with cargo init . If you don't have rust installed, install it with rustup . If you're on Linux rustup is probably already in your distro's repositories. After running cargo init , you should have a folder structure like this: . \u251c\u2500\u2500 Cargo.lock \u251c\u2500\u2500 Cargo.toml \u2514\u2500\u2500 src \u2514\u2500\u2500 main.rs Cargo.toml contains the manifest info for your Rust crate (crate is Rustacean for package). Mine looks like this: [package] name = \"snake-ggez\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] The src/ directory is where all of your Rust code goes. main.rs comes with Hello World already written: fn main() { println!(\"Hello, world!\"); } Run cargo build to build your project, and cargo run to run it. If you just want to check for project for syntax and type errors, run cargo check . It's a lot faster than cargo build .","title":"Create a project"},{"location":"00_projectsetup/#ggez-basics","text":"Adding ggez as a dependency is pretty simple. Just go to the dependencies section of your Cargo.toml and add ggez = \"0.8\" [package] name = \"snake-ggez\" version = \"0.1.0\" edition = \"2021\" # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] ggez = \"0.8.1\" Run cargo build now to download and build ggez and all of its dependencies. It might take a few minutes. The behavior of the program hasn't actually changed at all yet. cargo run will still just output \"Hello,","title":"ggez basics"},{"location":"01_justawindow/","text":"Time to start using ggez. We will try just to open a Window. From ggez's side, we'll need a Context , which is an object that provides access to the hardware: video for displaying the game, audio for playing sounds, keyboard for input and so on. A Context can be obtained from a ContextBuilder . To make a ContextBuilder you'll need a game ID. This will be used for the name of a directory in ~/.local/share on the player's computer, where game resources can be stored (see the filesystem module). You also need to provide a name for the game's author, but that's not used for GNU/Linux. To create them just call: let (mut ctx, event_loop) = ContextBuilder::new(\"hello-ggez\", \"author\").build() We could now start the event loop, but we need first an EventHandler . Were the logic of our game will reside. Just define a struct: struct MyGame {} and then implement the minimal EventHandler trait impl EventHandler for MyGame { fn update(&mut self, _ctx: &mut Context) -> GameResult { todo!() // todo!() is a macro which just exits the program with an error. } fn draw(&mut self, ctx: &mut Context) -> GameResult { todo!() } } Putting all together: use ggez::event::EventHandler; use ggez::Context; use ggez::ContextBuilder; use ggez::GameResult; fn main() { let (ctx, event_loop) = ContextBuilder::new(\"hello-ggez\", \"author\") .build() .expect(\"Could not create ggez context!\"); let my_game = MyGame {}; event::run(ctx, event_loop, my_game) } struct MyGame {} impl EventHandler for MyGame { fn update(&mut self, _ctx: &mut Context) -> GameResult { todo!() // todo!() is a macro which just exits the program with an error. } fn draw(&mut self, ctx: &mut Context) -> GameResult { todo!() } } Now try to run it and ... nothing! The application just panic. thread 'main' panicked at 'not yet implemented', src/main.rs:21:9 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace Nothing special, the event_loop is just calling the update() method with has just a todo!() , so try a nicer empty implementation. impl EventHandler for MyGame { fn update(&mut self, _ctx: &mut Context) -> GameResult { Ok(()) } fn draw(&mut self, ctx: &mut Context) -> GameResult { Ok(()) } } Try to run again and this time a Window appears ( Esc to close). We are drawing nothing so the Window background could display some garbage, better to color it: impl EventHandler for MyGame { ... fn draw(&mut self, ctx: &mut Context) -> GameResult { // Just a color for the background let color = Color::from([0.1, 0.2, 0.3, 1.0]); // Create a new Canvas that renders directly to the window surface. let canvas = Canvas::from_frame(ctx, color); // Finish drawing with this canvas and submit all the draw calls. canvas.finish(ctx) } } Canvas are the main places for drawing in ggez. Drawing are not made directly to the screen but instead on an internal buffer, so remeber to call finish() at the end to flush drawings or you will not see them. run another time and we finally have our fancy Window. As we are working with windows let set some attributes like title and size: let (ctx, event_loop) = ContextBuilder::new(\"snake-ggez\", \"author\") .window_setup(WindowSetup::default().title(\"Snake ggez\")) .window_mode(WindowMode::default().dimensions(800.0, 640.0)) .build() Read the documentation of WindowSetup and WindowMode for a complete list of attributes. You could find the complete source of this lesson here","title":"Open a Window"},{"location":"02_drawanimage/","text":"To write a game we need graphics, right? So let's start drawing something. Draw a shape The Canvas has a method draw(...) which we can use: pub fn draw(&mut self, drawable: &impl Drawable, param: impl Into<DrawParam>) So first we need a Drawable . We start with a simple sqare for the head of our snake: let head_color = Color::new(0.0, 1.0, 0.0, 1.0); let rect = Rect::new(10.0, 20.0, 32.0, 32.0); let head = Mesh::new_rectangle(ctx, DrawMode::fill(), rect, head_color)?; canvas.draw(&head, DrawParam::default()); So we first define the Color of our head, then the Rect : Rect::new(pos_x, pos_y, width, height) and finally we could create a Mesh which implemens the Drawable method. Note the DrawMode for the Mesh which is fill in our case (a filled shape) and the DrawParam for the draw(...) method which we will ignore for the moment setting it at its default values. Putting all together use ggez::conf::WindowMode; use ggez::conf::WindowSetup; use ggez::event; use ggez::event::EventHandler; use ggez::graphics::Canvas; use ggez::graphics::Color; use ggez::graphics::DrawMode; use ggez::graphics::DrawParam; use ggez::graphics::Mesh; use ggez::graphics::Rect; use ggez::Context; use ggez::ContextBuilder; use ggez::GameResult; fn main() { let (ctx, event_loop) = ContextBuilder::new(\"snake-ggez\", \"author\") .window_setup(WindowSetup::default().title(\"Snake ggez\")) .window_mode(WindowMode::default().dimensions(800.0, 640.0)) .build() .expect(\"Could not create ggez context!\"); let my_game = MyGame {}; event::run(ctx, event_loop, my_game) } struct MyGame {} impl EventHandler for MyGame { fn update(&mut self, _ctx: &mut Context) -> GameResult { Ok(()) } fn draw(&mut self, ctx: &mut Context) -> GameResult { // Just a color for the background let background_color = Color::new(0.1, 0.2, 0.3, 1.0); // Create a new Canvas that renders directly to the window surface. let mut canvas = Canvas::from_frame(ctx, background_color); // Create the snake head let head_color = Color::new(0.0, 1.0, 0.0, 1.0); let rect = Rect::new(10.0, 20.0, 32.0, 32.0); let head = Mesh::new_rectangle(ctx, DrawMode::fill(), rect, head_color)?; // Draw the snake head canvas.draw(&head, DrawParam::default()); // Finish drawing with this canvas and submit all the draw calls. canvas.finish(ctx) } } Is possible to write a game combining various shapes but I prefer to use images, so ... Draw an image Let's start with a minor problem. In order to display an image in the game, we need to have it stored somewhere. At runtime, ggez will look for resources in the resources/ directory next to the executable (not in $PWD ), or in resources.zip in the same place or in ~/.local/share/<gameid>/ . See also the documentation of the filesystem module and the FAQ entry about resource paths . You'll probably want to have a resources directory in the project's root and create a symbolic link to it in target/debug . . \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 resources \u2502 \u2514\u2500\u2500 my_image.png \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 main.rs \u2514\u2500\u2500 target \u2514\u2500\u2500 debug \u2514\u2500\u2500 resources -> ../../resources/ on github you can find the images for this lesson. To load an image resource we just need a Context and a path let image1 = graphics::Image::new(ctx, \"/my_image.png\")?; The image might be needed for the entire duration of the game, so a good owner for it might be a field of the game state struct. Also, we want to load the image as soon as the game starts, so we could do it in the new() function of the game state. Since Image::new() takes a &mut Context , so will the new() function. struct MyGame { head_image: Image, } impl MyGame { pub fn new(ctx: &mut Context) -> GameResult<MyGame> { let head_image = Image::from_path(ctx, \"/snakehead.png\")?; let g = MyGame { head_image }; Ok(g) } } and then just let my_dest = Vec2::new(500.0, 200.0); canvas.draw(&self.image1, DrawParam::default().dest(my_dest)); so we display the head PNG instead of the simple green sqauare we have drawn before. Note that an Image hasn't a destination position so we need to set the destination using the DrawParam . You could find the complete source of this lesson here As esercise you could try to draw a 32px grid on the window, it will be usefull in the following (hint use new_line(...) ).","title":"Draw an Image"},{"location":"02_drawanimage/#draw-a-shape","text":"The Canvas has a method draw(...) which we can use: pub fn draw(&mut self, drawable: &impl Drawable, param: impl Into<DrawParam>) So first we need a Drawable . We start with a simple sqare for the head of our snake: let head_color = Color::new(0.0, 1.0, 0.0, 1.0); let rect = Rect::new(10.0, 20.0, 32.0, 32.0); let head = Mesh::new_rectangle(ctx, DrawMode::fill(), rect, head_color)?; canvas.draw(&head, DrawParam::default()); So we first define the Color of our head, then the Rect : Rect::new(pos_x, pos_y, width, height) and finally we could create a Mesh which implemens the Drawable method. Note the DrawMode for the Mesh which is fill in our case (a filled shape) and the DrawParam for the draw(...) method which we will ignore for the moment setting it at its default values. Putting all together use ggez::conf::WindowMode; use ggez::conf::WindowSetup; use ggez::event; use ggez::event::EventHandler; use ggez::graphics::Canvas; use ggez::graphics::Color; use ggez::graphics::DrawMode; use ggez::graphics::DrawParam; use ggez::graphics::Mesh; use ggez::graphics::Rect; use ggez::Context; use ggez::ContextBuilder; use ggez::GameResult; fn main() { let (ctx, event_loop) = ContextBuilder::new(\"snake-ggez\", \"author\") .window_setup(WindowSetup::default().title(\"Snake ggez\")) .window_mode(WindowMode::default().dimensions(800.0, 640.0)) .build() .expect(\"Could not create ggez context!\"); let my_game = MyGame {}; event::run(ctx, event_loop, my_game) } struct MyGame {} impl EventHandler for MyGame { fn update(&mut self, _ctx: &mut Context) -> GameResult { Ok(()) } fn draw(&mut self, ctx: &mut Context) -> GameResult { // Just a color for the background let background_color = Color::new(0.1, 0.2, 0.3, 1.0); // Create a new Canvas that renders directly to the window surface. let mut canvas = Canvas::from_frame(ctx, background_color); // Create the snake head let head_color = Color::new(0.0, 1.0, 0.0, 1.0); let rect = Rect::new(10.0, 20.0, 32.0, 32.0); let head = Mesh::new_rectangle(ctx, DrawMode::fill(), rect, head_color)?; // Draw the snake head canvas.draw(&head, DrawParam::default()); // Finish drawing with this canvas and submit all the draw calls. canvas.finish(ctx) } } Is possible to write a game combining various shapes but I prefer to use images, so ...","title":"Draw a shape"},{"location":"02_drawanimage/#draw-an-image","text":"Let's start with a minor problem. In order to display an image in the game, we need to have it stored somewhere. At runtime, ggez will look for resources in the resources/ directory next to the executable (not in $PWD ), or in resources.zip in the same place or in ~/.local/share/<gameid>/ . See also the documentation of the filesystem module and the FAQ entry about resource paths . You'll probably want to have a resources directory in the project's root and create a symbolic link to it in target/debug . . \u251c\u2500\u2500 Cargo.toml \u251c\u2500\u2500 resources \u2502 \u2514\u2500\u2500 my_image.png \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 main.rs \u2514\u2500\u2500 target \u2514\u2500\u2500 debug \u2514\u2500\u2500 resources -> ../../resources/ on github you can find the images for this lesson. To load an image resource we just need a Context and a path let image1 = graphics::Image::new(ctx, \"/my_image.png\")?; The image might be needed for the entire duration of the game, so a good owner for it might be a field of the game state struct. Also, we want to load the image as soon as the game starts, so we could do it in the new() function of the game state. Since Image::new() takes a &mut Context , so will the new() function. struct MyGame { head_image: Image, } impl MyGame { pub fn new(ctx: &mut Context) -> GameResult<MyGame> { let head_image = Image::from_path(ctx, \"/snakehead.png\")?; let g = MyGame { head_image }; Ok(g) } } and then just let my_dest = Vec2::new(500.0, 200.0); canvas.draw(&self.image1, DrawParam::default().dest(my_dest)); so we display the head PNG instead of the simple green sqauare we have drawn before. Note that an Image hasn't a destination position so we need to set the destination using the DrawParam . You could find the complete source of this lesson here As esercise you could try to draw a 32px grid on the window, it will be usefull in the following (hint use new_line(...) ).","title":"Draw an image"},{"location":"03_drawtext/","text":"As we are drawing, sooner or later we should draw some text. So just start with a simple \"Hello World\". let text = Text::new(\"Hello World\"); canvas.draw(&text, DrawParam::default()); In general, you shouldn\u2019t call Text::new() in your draw loop. Text rendering is fairly expensive, so you should cache it and call Text::new() only when the text changes. But for the moment we can live with it. Easy? Let's tray to set some attributes // Create a new text let mut text = Text::new(\"Hello Snake!\"); // Set font size text.set_scale(PxScale::from(50.0)); // Set text position to the center of the screen let m = text.measure(ctx)?; let coords = [(WINDOW_WIDTH - m.x) / 2.0, (WINDOW_HEIGHT - m.y) / 2.0]; // Text color let color = Color::new(0.0, 1.0, 0.0, 1.0); // Set params let params = DrawParam::default().dest(coords).color(color); // Draw the text canvas.draw(&text, params); comments should be self explanatory, it's all for this lesson. You could find the complete source of this lesson here","title":"Draw text"},{"location":"04_inputhandling/","text":"Time to get some input from the user. We already seen the EventHandler trait and implemented the two required methods update(...) and draw(...) but EventHandler provide a lot more methods for handling user inputs, like key pressed, mouse events, window resize and so on. First try with key_down_event note that EventHandler already provide a default implementation for this method From the docs \"The default implementation of this will call ctx.request_quit() when the escape key is pressed. If you override this with your own event handler you have to re-implement that functionality yourself.\"\"\" So just print out which key is pressed fn key_down_event(&mut self, ctx: &mut Context, input: KeyInput, repeated: bool) -> GameResult { print!(\"{:?} {}\\n\", input, repeated); if input.keycode == Some(KeyCode::Escape) { ctx.request_quit(); } Ok(()) } run and see the output, do you note something strange? Try to use this method to move the snake head. Add the position of the head struct MyGame { head_image: Image, head_pos: Vec2, } impl MyGame { pub fn new(ctx: &mut Context) -> GameResult<MyGame> { let head_image = Image::from_path(ctx, \"/snakehead.png\")?; let head_pos = Vec2::new(64.0, 64.0); let g = MyGame { head_image, head_pos, }; Ok(g) } } and update the position when a key is pressed fn key_down_event(&mut self, ctx: &mut Context, input: KeyInput, repeated: bool) -> GameResult { match input.keycode.unwrap() { KeyCode::Down => self.head_pos.y += 1.0, KeyCode::Up => self.head_pos.y -= 1.0, KeyCode::Right => self.head_pos.x += 1.0, KeyCode::Left => self.head_pos.x -= 1.0, KeyCode::Escape => ctx.request_quit(), _ => {} } Ok(()) } Putting all together use ggez::conf::WindowMode; use ggez::conf::WindowSetup; use ggez::event; use ggez::event::EventHandler; use ggez::glam::Vec2; use ggez::graphics::Canvas; use ggez::graphics::Color; use ggez::graphics::DrawParam; use ggez::graphics::Image; use ggez::input::keyboard::KeyCode; use ggez::input::keyboard::KeyInput; use ggez::Context; use ggez::ContextBuilder; use ggez::GameResult; fn main() -> GameResult { let (mut ctx, event_loop) = ContextBuilder::new(\"snake-ggez\", \"author\") .window_setup(WindowSetup::default().title(\"Snake ggez\")) .window_mode(WindowMode::default().dimensions(800.0, 640.0)) .build() .expect(\"Could not create ggez context!\"); let my_game = MyGame::new(&mut ctx)?; event::run(ctx, event_loop, my_game) } struct MyGame { head_image: Image, head_pos: Vec2, } impl MyGame { pub fn new(ctx: &mut Context) -> GameResult<MyGame> { let head_image = Image::from_path(ctx, \"/snakehead.png\")?; let head_pos = Vec2::new(64.0, 64.0); let g = MyGame { head_image, head_pos, }; Ok(g) } } impl EventHandler for MyGame { fn update(&mut self, _ctx: &mut Context) -> GameResult { Ok(()) } fn draw(&mut self, ctx: &mut Context) -> GameResult { // Just a color for the background let background_color = Color::new(0.1, 0.2, 0.3, 1.0); // Create a new Canvas that renders directly to the window surface. let mut canvas = Canvas::from_frame(ctx, background_color); // Draw the snake head canvas.draw(&self.head_image, DrawParam::default().dest(self.head_pos)); // Finish drawing with this canvas and submit all the draw calls. canvas.finish(ctx) } fn key_down_event(&mut self, ctx: &mut Context, input: KeyInput, repeated: bool) -> GameResult { match input.keycode.unwrap() { KeyCode::Down => self.head_pos.y += 1.0, KeyCode::Up => self.head_pos.y -= 1.0, KeyCode::Right => self.head_pos.x += 1.0, KeyCode::Left => self.head_pos.x -= 1.0, KeyCode::Escape => ctx.request_quit(), _ => {} } Ok(()) } } Run the code and watch the snake head moving around when an arrow key is pressed. This time do you note something strange in the head movement? There is a small lapse between the first key press event which cause a lapse on the head movement. The key_down_event is not the right function for a game. ggez provides a method ctx.keyboard.is_key_pressed which solves our problem. Just put it in the update(...) method fn update(&mut self, ctx: &mut Context) -> GameResult { if ctx.keyboard.is_key_pressed(KeyCode::Down) { self.head_pos.y += 1.0; } else if ctx.keyboard.is_key_pressed(KeyCode::Up) { self.head_pos.y -= 1.0; } else if ctx.keyboard.is_key_pressed(KeyCode::Right) { self.head_pos.x += 1.0; } else if ctx.keyboard.is_key_pressed(KeyCode::Left) { self.head_pos.x -= 1.0; } Ok(()) } that's right! Now the head movement is smooth. You could find the complete source of this lesson here","title":"Input handling"},{"location":"05_gamelogic/","text":"We now have all the bricks to build our Snake game. Time to implement some logic. Start again from an empty template use ggez::conf::WindowMode; use ggez::conf::WindowSetup; use ggez::event; use ggez::event::EventHandler; use ggez::Context; use ggez::ContextBuilder; use ggez::GameResult; const WINDOW_WIDTH: f32 = 800.0; const WINDOW_HEIGHT: f32 = 640.0; fn main() -> GameResult { let (ctx, event_loop) = ContextBuilder::new(\"snake-ggez\", \"author\") .window_setup(WindowSetup::default().title(\"Snake ggez\")) .window_mode(WindowMode::default().dimensions(WINDOW_WIDTH, WINDOW_HEIGHT)) .build() .expect(\"Could not create ggez context!\"); let my_game = MyGame {}; event::run(ctx, event_loop, my_game) } struct MyGame {} impl EventHandler for MyGame { fn update(&mut self, ctx: &mut Context) -> GameResult { Ok(()) } fn draw(&mut self, ctx: &mut Context) -> GameResult { Ok(()) } } The grid First of all draw a 32px grid (did you do your homeworks?). The grid could be hide \\ show with the g key. struct MyGame { show_grid: bool, } impl EventHandler for MyGame { fn update(&mut self, _ctx: &mut Context) -> GameResult { Ok(()) } fn draw(&mut self, ctx: &mut Context) -> GameResult { // Just a color for the background let background_color = Color::new(0.075, 0.098, 0.149, 1.0); // Create a new Canvas that renders directly to the window surface. let mut canvas = Canvas::from_frame(ctx, background_color); // Draw the grid if self.show_grid { self.draw_grid(ctx, &mut canvas)?; } // Finish drawing with this canvas and submit all the draw calls. canvas.finish(ctx) } fn key_down_event(&mut self, _ctx: &mut Context, input: KeyInput, _repetd: bool) -> GameResult { match input.keycode.unwrap() { KeyCode::G => self.show_grid = !self.show_grid, _ => {} } Ok(()) } } The score Now a game needs a score, right? struct MyGame { score: u32, ..., } impl MyGame { ... fn draw_score(&self, ctx: &mut Context, canvas: &mut Canvas) -> GameResult { // Create a new text let s = format!(\"Points: {}\", self.score); let mut text = Text::new(s); // Set font size text.set_scale(PxScale::from(20.0)); // Set text position to the center of the screen let m = text.measure(ctx)?; let coords = [ WINDOW_WIDTH - m.x - CELL_SIZE / 2.0, WINDOW_HEIGHT - m.y - CELL_SIZE / 3.0, ]; // Set params let params = DrawParam::default().dest(coords).color(Color::YELLOW); // Draw the text canvas.draw(&text, params); Ok(()) } } impl EventHandler for MyGame { fn draw(&mut self, ctx: &mut Context) -> GameResult { ... // Draw the score self.draw_score(ctx, &mut canvas)?; // Finish drawing with this canvas and submit all the draw calls. canvas.finish(ctx) } } FPS Not really necessary for the game, but will be usefull to have a way to see how fast we are rendering. Ggez will give us FPS (Frame Per Second) and we should try to don't go below 60 FPS. let fps = ctx.time.fps(); draw it like the score for exercise. Draw the head Nothing new here, do you remember?, but we will use grid coords instead of pixel for the head position struct MyGame { head_image: Image, head_pos: Vec2, // This are the coords for the head as grid coords, not pixels ... } impl MyGame { pub fn new(ctx: &mut Context) -> GameResult<MyGame> { let head_image = Image::from_path(ctx, \"/snakehead.png\")?; let head_pos = Vec2::new(2.0, 2.0); let g = MyGame { head_image, head_pos, ... }; Ok(g) } } impl EventHandler for MyGame { fn draw(&mut self, ctx: &mut Context) -> GameResult { ... // Draw the snake head // convert to pixel let head_dest = Vec2::new(CELL_SIZE * self.head_pos.x, CELL_SIZE * self.head_pos.y); canvas.draw(&self.head_image, DrawParam::default().dest(head_dest)); .. } } Move the head We already implemented something like impl EventHandler for MyGame { fn update(&mut self, ctx: &mut Context) -> GameResult { if ctx.keyboard.is_key_pressed(KeyCode::Down) { self.head_pos.y += 1.0; if self.head_pos.y >= GRID_HEIGHT { self.head_pos.y = 0.0; } } else if ctx.keyboard.is_key_pressed(KeyCode::Up) { self.head_pos.y -= 1.0; if self.head_pos.y < 0.0 { self.head_pos.y = GRID_HEIGHT - 1.0; } } else if ctx.keyboard.is_key_pressed(KeyCode::Right) { self.head_pos.x += 1.0; if self.head_pos.x >= GRID_WIDTH { self.head_pos.x = 0.0; } } else if ctx.keyboard.is_key_pressed(KeyCode::Left) { self.head_pos.x -= 1.0; if self.head_pos.x < 0.0 { self.head_pos.x = GRID_WIDTH - 1.0; } } Ok(()) } } but doing this the head moves only when we press a key, instead we need the head to keep moving, so let's introduce a direction (and some auxilary structs) #[derive(Clone, Copy, Debug, PartialEq, Eq)] enum Direction { Up, Down, Left, Right, } #[derive(Clone, Copy, PartialEq, Eq, Debug)] struct GridPosition { x: i16, y: i16, } impl GridPosition { pub fn new(x: i16, y: i16) -> Self { GridPosition { x, y } } pub fn to_direction(self: GridPosition, dir: Direction) -> Self { match dir { Direction::Down => { let mut y = self.y + 1; if y >= GRID_HEIGHT { y = 0; } GridPosition { x: self.x, y } } Direction::Up => { let mut y = self.y - 1; if y < 0 { y = GRID_HEIGHT - 1; } GridPosition { x: self.x, y } } Direction::Right => { let mut x = self.x + 1; if x >= GRID_WIDTH { x = 0; } GridPosition { x, y: self.y } } Direction::Left => { let mut x = self.x - 1; if x < 0 { x = GRID_WIDTH - 1; } GridPosition { x, y: self.y } } } } } struct MyGame { dir: Direction, head_pos: GridPosition, ... } impl EventHandler for MyGame { fn update(&mut self, ctx: &mut Context) -> GameResult { self.process_input(ctx); self.head_pos = self.head_pos.to_direction(self.dir); Ok(()) } ... } impl MyGame { fn process_input(&mut self, ctx: &Context) { if ctx.keyboard.is_key_pressed(KeyCode::Down) { self.dir = Direction::Down; } else if ctx.keyboard.is_key_pressed(KeyCode::Up) { self.dir = Direction::Up; } else if ctx.keyboard.is_key_pressed(KeyCode::Right) { self.dir = Direction::Right; } else if ctx.keyboard.is_key_pressed(KeyCode::Left) { self.dir = Direction::Left; } } } now the head is moving but too fast! We need a way to decouple the head movement speed from the FPS. Let's add a timer and and check the delta const MOVE_TIME: Duration = Duration::from_millis(300); struct MyGame { head_timer: Duration, ... } impl EventHandler for MyGame { fn update(&mut self, ctx: &mut Context) -> GameResult { self.process_input(ctx); self.head_timer += ctx.time.delta(); if self.head_timer >= MOVE_TIME { self.head_pos.to_direction(self.dir); self.head_timer = Duration::from_millis(0); } Ok(()) } ... }","title":"Game logic"},{"location":"05_gamelogic/#the-grid","text":"First of all draw a 32px grid (did you do your homeworks?). The grid could be hide \\ show with the g key. struct MyGame { show_grid: bool, } impl EventHandler for MyGame { fn update(&mut self, _ctx: &mut Context) -> GameResult { Ok(()) } fn draw(&mut self, ctx: &mut Context) -> GameResult { // Just a color for the background let background_color = Color::new(0.075, 0.098, 0.149, 1.0); // Create a new Canvas that renders directly to the window surface. let mut canvas = Canvas::from_frame(ctx, background_color); // Draw the grid if self.show_grid { self.draw_grid(ctx, &mut canvas)?; } // Finish drawing with this canvas and submit all the draw calls. canvas.finish(ctx) } fn key_down_event(&mut self, _ctx: &mut Context, input: KeyInput, _repetd: bool) -> GameResult { match input.keycode.unwrap() { KeyCode::G => self.show_grid = !self.show_grid, _ => {} } Ok(()) } }","title":"The grid"},{"location":"05_gamelogic/#the-score","text":"Now a game needs a score, right? struct MyGame { score: u32, ..., } impl MyGame { ... fn draw_score(&self, ctx: &mut Context, canvas: &mut Canvas) -> GameResult { // Create a new text let s = format!(\"Points: {}\", self.score); let mut text = Text::new(s); // Set font size text.set_scale(PxScale::from(20.0)); // Set text position to the center of the screen let m = text.measure(ctx)?; let coords = [ WINDOW_WIDTH - m.x - CELL_SIZE / 2.0, WINDOW_HEIGHT - m.y - CELL_SIZE / 3.0, ]; // Set params let params = DrawParam::default().dest(coords).color(Color::YELLOW); // Draw the text canvas.draw(&text, params); Ok(()) } } impl EventHandler for MyGame { fn draw(&mut self, ctx: &mut Context) -> GameResult { ... // Draw the score self.draw_score(ctx, &mut canvas)?; // Finish drawing with this canvas and submit all the draw calls. canvas.finish(ctx) } }","title":"The score"},{"location":"05_gamelogic/#fps","text":"Not really necessary for the game, but will be usefull to have a way to see how fast we are rendering. Ggez will give us FPS (Frame Per Second) and we should try to don't go below 60 FPS. let fps = ctx.time.fps(); draw it like the score for exercise.","title":"FPS"},{"location":"05_gamelogic/#draw-the-head","text":"Nothing new here, do you remember?, but we will use grid coords instead of pixel for the head position struct MyGame { head_image: Image, head_pos: Vec2, // This are the coords for the head as grid coords, not pixels ... } impl MyGame { pub fn new(ctx: &mut Context) -> GameResult<MyGame> { let head_image = Image::from_path(ctx, \"/snakehead.png\")?; let head_pos = Vec2::new(2.0, 2.0); let g = MyGame { head_image, head_pos, ... }; Ok(g) } } impl EventHandler for MyGame { fn draw(&mut self, ctx: &mut Context) -> GameResult { ... // Draw the snake head // convert to pixel let head_dest = Vec2::new(CELL_SIZE * self.head_pos.x, CELL_SIZE * self.head_pos.y); canvas.draw(&self.head_image, DrawParam::default().dest(head_dest)); .. } }","title":"Draw the head"},{"location":"05_gamelogic/#move-the-head","text":"We already implemented something like impl EventHandler for MyGame { fn update(&mut self, ctx: &mut Context) -> GameResult { if ctx.keyboard.is_key_pressed(KeyCode::Down) { self.head_pos.y += 1.0; if self.head_pos.y >= GRID_HEIGHT { self.head_pos.y = 0.0; } } else if ctx.keyboard.is_key_pressed(KeyCode::Up) { self.head_pos.y -= 1.0; if self.head_pos.y < 0.0 { self.head_pos.y = GRID_HEIGHT - 1.0; } } else if ctx.keyboard.is_key_pressed(KeyCode::Right) { self.head_pos.x += 1.0; if self.head_pos.x >= GRID_WIDTH { self.head_pos.x = 0.0; } } else if ctx.keyboard.is_key_pressed(KeyCode::Left) { self.head_pos.x -= 1.0; if self.head_pos.x < 0.0 { self.head_pos.x = GRID_WIDTH - 1.0; } } Ok(()) } } but doing this the head moves only when we press a key, instead we need the head to keep moving, so let's introduce a direction (and some auxilary structs) #[derive(Clone, Copy, Debug, PartialEq, Eq)] enum Direction { Up, Down, Left, Right, } #[derive(Clone, Copy, PartialEq, Eq, Debug)] struct GridPosition { x: i16, y: i16, } impl GridPosition { pub fn new(x: i16, y: i16) -> Self { GridPosition { x, y } } pub fn to_direction(self: GridPosition, dir: Direction) -> Self { match dir { Direction::Down => { let mut y = self.y + 1; if y >= GRID_HEIGHT { y = 0; } GridPosition { x: self.x, y } } Direction::Up => { let mut y = self.y - 1; if y < 0 { y = GRID_HEIGHT - 1; } GridPosition { x: self.x, y } } Direction::Right => { let mut x = self.x + 1; if x >= GRID_WIDTH { x = 0; } GridPosition { x, y: self.y } } Direction::Left => { let mut x = self.x - 1; if x < 0 { x = GRID_WIDTH - 1; } GridPosition { x, y: self.y } } } } } struct MyGame { dir: Direction, head_pos: GridPosition, ... } impl EventHandler for MyGame { fn update(&mut self, ctx: &mut Context) -> GameResult { self.process_input(ctx); self.head_pos = self.head_pos.to_direction(self.dir); Ok(()) } ... } impl MyGame { fn process_input(&mut self, ctx: &Context) { if ctx.keyboard.is_key_pressed(KeyCode::Down) { self.dir = Direction::Down; } else if ctx.keyboard.is_key_pressed(KeyCode::Up) { self.dir = Direction::Up; } else if ctx.keyboard.is_key_pressed(KeyCode::Right) { self.dir = Direction::Right; } else if ctx.keyboard.is_key_pressed(KeyCode::Left) { self.dir = Direction::Left; } } } now the head is moving but too fast! We need a way to decouple the head movement speed from the FPS. Let's add a timer and and check the delta const MOVE_TIME: Duration = Duration::from_millis(300); struct MyGame { head_timer: Duration, ... } impl EventHandler for MyGame { fn update(&mut self, ctx: &mut Context) -> GameResult { self.process_input(ctx); self.head_timer += ctx.time.delta(); if self.head_timer >= MOVE_TIME { self.head_pos.to_direction(self.dir); self.head_timer = Duration::from_millis(0); } Ok(()) } ... }","title":"Move the head"}]}