<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://geckoblu-games.github.io/snake-ggez/05_gamelogic/">
    <link rel="shortcut icon" href="../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Game logic - Writing a Snake game with Rust and ggez</title>
    <link href="../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../js/jquery-3.2.1.min.js"></script>
    <script src="../js/bootstrap-3.3.7.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "The grid", url: "#_top", children: [
          ]},
          {title: "The score", url: "#the-score", children: [
          ]},
          {title: "FPS", url: "#fps", children: [
          ]},
          {title: "Draw the head", url: "#draw-the-head", children: [
          ]},
          {title: "Move the head", url: "#move-the-head", children: [
          ]},
        ];

    </script>
    <script src="../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav">
      <a href="../04_inputhandling/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../04_inputhandling/" class="btn btn-xs btn-link">
        Input handling
      </a>
    </div>
    
  </div>

    

    <p>We now have all the bricks to build our Snake game.</p>
<p>Time to implement some logic.</p>
<p>Start again from an empty template</p>
<pre><code class="language-rust">use ggez::conf::WindowMode;
use ggez::conf::WindowSetup;
use ggez::event;
use ggez::event::EventHandler;
use ggez::Context;
use ggez::ContextBuilder;
use ggez::GameResult;

const WINDOW_WIDTH: f32 = 800.0;
const WINDOW_HEIGHT: f32 = 640.0;

fn main() -&gt; GameResult {
    let (ctx, event_loop) = ContextBuilder::new(&quot;snake-ggez&quot;, &quot;author&quot;)
        .window_setup(WindowSetup::default().title(&quot;Snake ggez&quot;))
        .window_mode(WindowMode::default().dimensions(WINDOW_WIDTH, WINDOW_HEIGHT))
        .build()
        .expect(&quot;Could not create ggez context!&quot;);

    let my_game = MyGame {};

    event::run(ctx, event_loop, my_game)
}

struct MyGame {}

impl EventHandler for MyGame {
    fn update(&amp;mut self, ctx: &amp;mut Context) -&gt; GameResult {
        Ok(())
    }

    fn draw(&amp;mut self, ctx: &amp;mut Context) -&gt; GameResult {
        Ok(())
    }
}
</code></pre>
<h2 id="the-grid">The grid</h2>
<p>First of all draw a 32px grid (did you do your homeworks?). 
The grid could be hide \ show with the <code>g</code> key.</p>
<pre><code class="language-rust">struct MyGame {
    show_grid: bool,
}

impl EventHandler for MyGame {
    fn update(&amp;mut self, _ctx: &amp;mut Context) -&gt; GameResult {
        Ok(())
    }

    fn draw(&amp;mut self, ctx: &amp;mut Context) -&gt; GameResult {
        // Just a color for the background
        let background_color = Color::new(0.075, 0.098, 0.149, 1.0);

        // Create a new Canvas that renders directly to the window surface.
        let mut canvas = Canvas::from_frame(ctx, background_color);

        // Draw the grid
        if self.show_grid {
            self.draw_grid(ctx, &amp;mut canvas)?;
        }

        // Finish drawing with this canvas and submit all the draw calls.
        canvas.finish(ctx)
    }

    fn key_down_event(&amp;mut self, _ctx: &amp;mut Context, input: KeyInput, _repetd: bool) -&gt; GameResult {
        match input.keycode.unwrap() {
            KeyCode::G =&gt; self.show_grid = !self.show_grid,
            _ =&gt; {}
        }

        Ok(())
    }
}

</code></pre>
<h2 id="the-score">The score</h2>
<p>Now a game needs a score, right?</p>
<pre><code class="language-rust">struct MyGame {
    score: u32,
    ...,
}

impl MyGame {

    ...

    fn draw_score(&amp;self, ctx: &amp;mut Context, canvas: &amp;mut Canvas) -&gt; GameResult {
        // Create a new text
        let s = format!(&quot;Points: {}&quot;, self.score);
        let mut text = Text::new(s);

        // Set font size
        text.set_scale(PxScale::from(20.0));

        // Set text position to the center of the screen
        let m = text.measure(ctx)?;
        let coords = [
            WINDOW_WIDTH - m.x - CELL_SIZE / 2.0,
            WINDOW_HEIGHT - m.y - CELL_SIZE / 3.0,
        ];

        // Set params
        let params = DrawParam::default().dest(coords).color(Color::YELLOW);

        // Draw the text
        canvas.draw(&amp;text, params);

        Ok(())
    }
}

impl EventHandler for MyGame {

    fn draw(&amp;mut self, ctx: &amp;mut Context) -&gt; GameResult {

        ...

        // Draw the score
        self.draw_score(ctx, &amp;mut canvas)?;

        // Finish drawing with this canvas and submit all the draw calls.
        canvas.finish(ctx)
    }
}
</code></pre>
<h2 id="fps">FPS</h2>
<p>Not really necessary for the game, but will be usefull to have a way 
to see how fast we are rendering. Ggez will give us FPS (Frame Per Second)
and we should try to don't go below 60 FPS.</p>
<pre><code class="language-rust">let fps = ctx.time.fps();

</code></pre>
<p>draw it like the score for exercise.</p>
<h2 id="draw-the-head">Draw the head</h2>
<p>Nothing new here, do you remember?, but we will use grid coords instead of pixel for the head position</p>
<pre><code class="language-rust">struct MyGame {
    head_image: Image,
    head_pos: Vec2, // This are the coords for the head as grid coords, not pixels  
    ...
}

impl MyGame {
    pub fn new(ctx: &amp;mut Context) -&gt; GameResult&lt;MyGame&gt; {
        let head_image = Image::from_path(ctx, &quot;/snakehead.png&quot;)?;
        let head_pos = Vec2::new(2.0, 2.0);

        let g = MyGame {
            head_image,
            head_pos,
            ...
        };
        Ok(g)
    }
}

impl EventHandler for MyGame {

    fn draw(&amp;mut self, ctx: &amp;mut Context) -&gt; GameResult {

        ...

        // Draw the snake head
        // convert to pixel
        let head_dest = Vec2::new(CELL_SIZE * self.head_pos.x, CELL_SIZE * self.head_pos.y);
        canvas.draw(&amp;self.head_image, DrawParam::default().dest(head_dest));

        ..
    }

}
</code></pre>
<h2 id="move-the-head">Move the head</h2>
<p>We already implemented something like</p>
<pre><code class="language-rust">impl EventHandler for MyGame {
    fn update(&amp;mut self, ctx: &amp;mut Context) -&gt; GameResult {
        if ctx.keyboard.is_key_pressed(KeyCode::Down) {
            self.head_pos.y += 1.0;
            if self.head_pos.y &gt;= GRID_HEIGHT {
                self.head_pos.y = 0.0;
            }
        } else if ctx.keyboard.is_key_pressed(KeyCode::Up) {
            self.head_pos.y -= 1.0;
            if self.head_pos.y &lt; 0.0 {
                self.head_pos.y = GRID_HEIGHT - 1.0;
            }
        } else if ctx.keyboard.is_key_pressed(KeyCode::Right) {
            self.head_pos.x += 1.0;
            if self.head_pos.x &gt;= GRID_WIDTH {
                self.head_pos.x = 0.0;
            }
        } else if ctx.keyboard.is_key_pressed(KeyCode::Left) {
            self.head_pos.x -= 1.0;
            if self.head_pos.x &lt; 0.0 {
                self.head_pos.x = GRID_WIDTH - 1.0;
            }
        }
        Ok(())
    }
}
</code></pre>
<p>but doing this the head moves only when we press a key,
instead we need the head to keep moving, so let's introduce a direction (and some auxilary structs)</p>
<pre><code class="language-rust">
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum Direction {
    Up,
    Down,
    Left,
    Right,
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
struct GridPosition {
    x: i16,
    y: i16,
}

impl GridPosition {
    pub fn new(x: i16, y: i16) -&gt; Self {
        GridPosition { x, y }
    }

    pub fn to_direction(self: GridPosition, dir: Direction) -&gt; Self {
        match dir {
            Direction::Down =&gt; {
                let mut y = self.y + 1;
                if y &gt;= GRID_HEIGHT {
                    y = 0;
                }
                GridPosition { x: self.x, y }
            }
            Direction::Up =&gt; {
                let mut y = self.y - 1;
                if y &lt; 0 {
                    y = GRID_HEIGHT - 1;
                }
                GridPosition { x: self.x, y }
            }
            Direction::Right =&gt; {
                let mut x = self.x + 1;
                if x &gt;= GRID_WIDTH {
                    x = 0;
                }
                GridPosition { x, y: self.y }
            }
            Direction::Left =&gt; {
                let mut x = self.x - 1;
                if x &lt; 0 {
                    x = GRID_WIDTH - 1;
                }
                GridPosition { x, y: self.y }
            }
        }
    }
}

struct MyGame {
    dir: Direction,
    head_pos: GridPosition,
    ...
}

impl EventHandler for MyGame {
    fn update(&amp;mut self, ctx: &amp;mut Context) -&gt; GameResult {
        self.process_input(ctx);

        self.head_pos = self.head_pos.to_direction(self.dir);

        Ok(())
    }

    ...
}

impl MyGame {
    fn process_input(&amp;mut self, ctx: &amp;Context) {
        if ctx.keyboard.is_key_pressed(KeyCode::Down) {
            self.dir = Direction::Down;
        } else if ctx.keyboard.is_key_pressed(KeyCode::Up) {
            self.dir = Direction::Up;
        } else if ctx.keyboard.is_key_pressed(KeyCode::Right) {
            self.dir = Direction::Right;
        } else if ctx.keyboard.is_key_pressed(KeyCode::Left) {
            self.dir = Direction::Left;
        }
    }
}
</code></pre>
<p>now the head is moving but too fast!</p>
<p>We need a way to decouple the head movement speed from the FPS.</p>
<p>Let's add a timer and and check the <a href="https://docs.rs/ggez/0.8.1/ggez/timer/struct.TimeContext.html#method.delta"><code>delta</code></a></p>
<pre><code class="language-rust">const MOVE_TIME: Duration = Duration::from_millis(300);

struct MyGame {
    head_timer: Duration,
    ...
}

impl EventHandler for MyGame {
    fn update(&amp;mut self, ctx: &amp;mut Context) -&gt; GameResult {
        self.process_input(ctx);

        self.head_timer += ctx.time.delta();

        if self.head_timer &gt;= MOVE_TIME {
            self.head_pos.to_direction(self.dir);
            self.head_timer = Duration::from_millis(0);
        }

        Ok(())
    }

    ...
}
</code></pre>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav">
      <a href="../04_inputhandling/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../04_inputhandling/" class="btn btn-xs btn-link">
        Input handling
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>